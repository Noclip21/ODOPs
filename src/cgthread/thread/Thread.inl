#pragma once

#include "Thread.h"


////////////////////////////////////////////////////////////////////////////////
Thread::Thread()
{ 
	_kill     = false;
	_thread   = std::thread(_loop,this);
	_dispatchMutex.lock();
}
////////////////////////////////////////////////////////////////////////////////
Thread::~Thread()
{
	_kill = true;
	_dispatchMutex.unlock();
	if(_thread.joinable()) _thread.join();
}
////////////////////////////////////////////////////////////////////////////////
void Thread::_loop(Thread* t)
{
	while(true)
	{
		std::lock_guard<std::mutex> lock(t->_dispatchMutex);
		if(t->_kill) return;
		t->_callback();
		t->_returnMutex.unlock();
		t->_dispatchMutex.lock();
	}
}
////////////////////////////////////////////////////////////////////////////////
Thread& Thread::getThread(const uint64 id)
{
	static Thread* threads = new Thread[numThreads()];
	return threads[id];
};
////////////////////////////////////////////////////////////////////////////////
const uint64 Thread::numThreads()
{
	return std::thread::hardware_concurrency();
}
////////////////////////////////////////////////////////////////////////////////
void Thread::setCallback(auto callback)
{
	_callback = callback;
}
////////////////////////////////////////////////////////////////////////////////
void Thread::dispatch()
{ 
	_returnMutex.lock();
	_dispatchMutex.unlock();
}
////////////////////////////////////////////////////////////////////////////////
void Thread::sync()
{
	std::lock_guard<std::mutex> lock(_returnMutex);
}
////////////////////////////////////////////////////////////////////////////////
